
## Usage


The simplest usage is just to run `thought run` from your project root directory.
In the default configuration, this will generate a `README.md` from the information in the `package.json`.

Consider the following example 

{{{dirTree 'examples/example-project' '!(README.md|CONTRIBUTING.md)'}}}

and have a look at the files
[index.js](examples/example-project/index.js),
[examples/example.js](examples/example-project/examples/example.js) and
[examples/example.js](examples/example-project/examples/example.js),
[LICENSE.md](examples/example-project/LICENSE.md),
[package.json](examples/example-project/package.json)

Thought will render information from `package.json`, include the `examples/examples.js`, 
execute the `examples/example.js` file and include the process-output and reference the `LICENSE.md`
into the [README.md](examples/example-project/README.md). It will also generate a default 
[CONTRIBUTING.md](examples/example-project/CONTRIBUTING.md).

*Note: The CONTRIBUTING-text contains some parts that may be subjective (such as including the 
[`standard`](https://github.com/feross/standard) coding style. I am open for different texts or 
ideas for modular approaches. Just file a github issue for discussion.*


### CLI options

Calling `thought --help` will print a command-line reference:

{{{exec 'bin/thought.js --help'}}}

### Calling `thought` from node.

{{{example 'examples/javascript-usage.js' 'txt'}}}

### Using `thought` as version-script for npm

npm supports a `version` script from version 2.13.0 on. This script
is called when invoking [npm version ...](https://docs.npmjs.com/cli/version)
after bumping the version number but prior to commiting the change.

Using `thought init` you can install scripts for `version` and `preversion` in your package.json 
that will run `thought run -a` on every version bump. This will include the updated documenation
in the same commit that contains the version bump. Furthermore, if you (or any other contributor 
of your module) is using npm prior to version 2.13.0. The preversion-script will fail.

This is especially helpful when using the helper `withPackageOf` to include links to files
in your github repository (since these links include the version tag on github).

### Overriding templates and partials

All templates and partials can be overridden by customized versions (but it is currently
not possible to remove a template completely).
You can find the default configuration in the [partials/](partials/) directory. It currently 
has the structure.

{{dirTree 'handlebars/' }}

Every file in the `templates/` directory will create a file in your project root (removing 
the `.hbs` extension). The partials are included by calling for example `\{{> api.md}}` (also without
the `.hbs` extension) from a template or another partial.

You can now create a directory `.thought` in the your project root, that has the same structure.
If you create a file `.thought/partials/contributing.md.hbs`, it will replace the default
`partials/contributing.md.hbs` file. Same for templates.

### Customizing the preprocessor

Thought uses `preprocessor.js` function to extend the `package.json` before passing it to the handlebars
engine. You can create a file named `.thought/preprocessor.js` in your project to supply your own 
preprocessor. If you do that, you should run the old preprocessor by calling `this.parent(data)` from within
your custom function. Some partials and template rely on the data created there.

### Customizing helpers

Thought comes with a default set of Handlebars-helpers that are called from within the template.
If you want to provide your own helpers (for example to perform some project-specific computations) 
you can create a file named `.thought/helpers.js` in your project. This file should export an object 
of helper-functions like

```js
module.exports = {
  myHelper: function(value) { ... },
  myHelper2: function(value) { ... },
}
```

Those helpers are registered with the handlebars engine in addition to the default helpers. If the name 
equals a default helper, that helper will be replaced by your helper. Currently there is no way to call
the old helper from within the new helper.

Thought implicitly uses the [promised-handlebars](https://github.com/nknapp/promised-handlebars)-package
to allow helpers that return promises. So, in your helpers, you will never receive a promise as parameter or 
as context data, but if you return promises, they will be resolved seamlessly. 




                                                 